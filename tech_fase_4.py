# -*- coding: utf-8 -*-
"""Tech_fase_4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tFyNniWRPkuSuLTQcrwUpuGrf25zZjDM

# Tech challenge fase 4

## Importando o arquivo do ipea para o notebook
"""

pip install pmdarima

import pandas as pd
from plotly import graph_objs as go

import matplotlib.pyplot as plt

# '''PEGANDO DO GITHUB UMA EXTRAÇÃO ESTÁTICA'''

# # Download the Excel file using wget:
# !wget 'https://raw.githubusercontent.com/marialuisamartins/tech_fase4/6ad3e07bc901fd984eedb3030510b2816aaf7383/ipeadata%5B03-11-2024-01-09%5D.xlsx' -O ipeadata.xlsx

# # Read the Excel file using pd.read_excel, optionally specifying the engine
# ipeadata = pd.read_excel('ipeadata.xlsx', engine='openpyxl') # engine='openpyxl' is the default and generally won't need to be specified for .xlsx files
# # if this file were a .xls you would need to change it to engine='xlrd'

'''PEGANDO DO SITE DIRETAMENTE USANDO WEB SCRAPPING'''

import requests
from bs4 import BeautifulSoup
from io import StringIO

# URL do site
url = "http://www.ipeadata.gov.br/ExibeSerie.aspx?module=m&serid=1650971490&oper=view"

# Fazendo a requisição para obter o conteúdo da página
response = requests.get(url)

# Verifica se a requisição foi bem-sucedida
if response.status_code == 200:
    # Parse do conteúdo HTML
    soup = BeautifulSoup(response.content, 'html.parser')

    # Localiza a tabela pelo ID
    table = soup.find('table', id='grd_DXMainTable')

    # Converte a tabela HTML para string para processamento posterior
    html_table = str(table)

    # Lê a tabela utilizando StringIO para evitar o FutureWarning
    ipeadata = pd.read_html(StringIO(html_table))[0]

    # Renomeia as colunas, assumindo que as duas primeiras são "Data" e "Preço"
    ipeadata = ipeadata.iloc[1:]  # Remove as linhas de cabeçalho duplicadas
    ipeadata.columns = ["Data", "Preço"]  # Define novos nomes de colunas
    ipeadata.reset_index(drop=True, inplace=True)  # Reseta os índices

    # Remove linhas vazias e ajusta o formato de preço
    ipeadata = ipeadata.dropna()
    ipeadata["Preço"] = pd.to_numeric(ipeadata["Preço"], errors="coerce")  # Converte para float
    ipeadata["Preço"] = ipeadata["Preço"] / 100  # Corrige os valores dividindo por 100

    print(ipeadata.head())  # Exibe as primeiras linhas do dataframe
else:
    print(f"Erro ao acessar o site: {response.status_code}")

"""Arrumando"""

# Converte a coluna 'data' para o tipo datetime
ipeadata['Data'] = pd.to_datetime(ipeadata['Data'], errors='coerce', dayfirst=True)

"""## Análise utilizando gráficos"""

ipeadata.reset_index(inplace=True)
ipeadata["Data"] = pd.to_datetime(ipeadata["Data"], format="%Y-%m-%d")
ipeadata.head()

dados = ipeadata.copy()

fig = go.Figure()
fig.add_trace(go.Scatter(x=dados['Data'], y=dados['Preço'], name="Preço do Petróleo"))
fig.layout.update(title_text='Preço do Petróleo', xaxis_rangeslider_visible=True)
fig.show()

from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error
from sklearn.metrics import mean_absolute_percentage_error
import numpy as np
import math

def wmape(y_true, y_pred):
  return np.abs(y_true-y_pred).sum() / np.abs(y_true).sum()

"""# **ARIMA**"""

ajusta = dados.set_index("Data").resample('1D').ffill()
ajusta

print(type(ajusta['2021-01-01':]))
print(ajusta['2021-01-01':].head())

from statsmodels.tsa.seasonal import seasonal_decompose
import matplotlib.pyplot as plt

if not isinstance(ajusta.index, pd.DatetimeIndex):
    ajusta.index = pd.to_datetime(ajusta.index)

try:
    resultado = seasonal_decompose(ajusta['2021-01-01':]['Preço'], model='additive', period=365)

    # Plot the decomposition results
    fig = resultado.plot()
    plt.show()
except TypeError as e:
    print(f"TypeError encountered: {e}")
except Exception as e:
    print(f"An error occurred: {e}")

# Configurando o gráfico de linha
plt.figure(figsize=(12, 3))
plt.plot(dados['Data'], dados['Preço'], color='blue')
plt.title('Preço do Petróleo ao Longo do Tempo')
plt.xlabel('Data')
plt.ylabel('Preço')
plt.grid(True)
plt.show()

plt.figure(figsize=(12, 3))
plt.hist(dados['Preço'], bins=30, color='skyblue', edgecolor='black')
plt.title('Distribuição do Preço do Petróleo')
plt.xlabel('Preço')
plt.ylabel('Frequência')
plt.grid(True)
plt.show()

# Definindo janelas para médias móveis
dados['media_movel_7'] = dados['Preço'].rolling(window=7).mean()
dados['media_movel_30'] = dados['Preço'].rolling(window=30).mean()

# Plotando o preço e as médias móveis
plt.figure(figsize=(14, 3))
plt.plot(dados['Data'], dados['Preço'], label='Preço Diário', color='blue', alpha=0.5)
plt.plot(dados['Data'], dados['media_movel_7'], label='Média Móvel de 7 dias', color='orange')
plt.plot(dados['Data'], dados['media_movel_30'], label='Média Móvel de 30 dias', color='green')
plt.title('Preço do Petróleo com Médias Móveis')
plt.xlabel('Data')
plt.ylabel('Preço')
plt.legend()
plt.grid(True)
plt.show()

"""## **Teste de estacionariedade**"""

from statsmodels.tsa.stattools import adfuller

result = adfuller(dados['Preço'])

print("Dickey-Fuller Aumentado")
print('Teste Estatístico: {:.4f}'.format(result[0]))
print('Valor-p: {:.4f}'.format(result[1]))

print('Valores Críticos:')
for key, value in result[4].items():
    print(f'\t{key}: {value}')

# Interpretar o resultado do teste
alpha = 0.05
if result[1] < alpha:
    msg = 'Série é estacionária (rejeita H0)'
else:
    msg = 'Série não é estacionária (falha em rejeitar H0)'

print('\nResultado do teste de estacionariedade após 1ª diferenciação:')
print(msg)

diff = adfuller(dados["Preço"].diff().dropna())
print("Dickey-Fuller Aumentado")
print('Teste Estatístico: {:.4f}'.format(diff[0]))
print('Valor-p: {:.4f}'.format(diff[1]))


print('Valores Críticos:')
for key, value in diff[4].items():
	print('\t{}: {:.4f}'.format(key, value))

# Interpretar o resultado do teste
alpha = 0.05
if diff[1] < alpha:
    msg = 'Série é estacionária (rejeita H0)'
else:
    msg = 'Série não é estacionária (falha em rejeitar H0)'

print('\nResultado do teste de estacionariedade após 1ª diferenciação:')
print(msg)

"""# **Modelos**"""

ajusta = ajusta.drop('index', axis=1)
ajusta.head()

ajusta.tail()

train_ARIMA = ajusta[:'2014-12-31']
test_ARIMA = ajusta['2015-01-01':]

fig, ax = plt.subplots(figsize = (15,5))
ax.plot(train_ARIMA, 'blue', test_ARIMA, 'green')
plt.title("Dados de teste e treino")
plt.xlabel('Período')
plt.grid(alpha=0.5)
plt.show()

print(f'Qtd de dados de treino: {train_ARIMA.shape[0]} \n\nQtd de dados de teste: {test_ARIMA.shape[0]}')

from statsmodels.tsa.arima.model import ARIMA
model_arima = ARIMA(train_ARIMA, order =(1,1,1))
arima_fit = model_arima.fit()
print(arima_fit.summary())

pred_ARIMA = arima_fit.predict(train_ARIMA.shape[0], ajusta.shape[0]-1, dynamic=True)
pred_ARIMA.shape

fig, ax = plt.subplots(figsize = (10,5))
fig.suptitle('Previsão do preço do Petróleo')

dados_treinoA, = plt.plot(train_ARIMA.loc['2007-01-01':],"b", label = "Histórico")
dados_testeA, = plt.plot(test_ARIMA, "r", label = "Real")
dados_predA, = plt.plot(pred_ARIMA, "g", label = "Forecast")
plt.legend(handles=[dados_treinoA, dados_testeA, dados_predA])
plt.xlabel('Período')
plt.show()

mae_arimam = mean_absolute_error(test_ARIMA.values, pred_ARIMA.values)
mse_arimam = mean_squared_error(test_ARIMA.values, pred_ARIMA.values)
rmse_arimam = math.sqrt(mse_arimam)
mape_arimam = mean_absolute_percentage_error(test_ARIMA.values, pred_ARIMA.values)
wmape_arimam = wmape(test_ARIMA.values, pred_ARIMA.values)
print(f"MAE: {mae_arimam:.5f}")
print(f"MSE: {mse_arimam:.5f}")
print(f"RMSE: {rmse_arimam:.5f}")
print(f"MAPE: {mape_arimam:.2%}")
print(f"WMAPE: {wmape_arimam:.2%}")

"""Prophet"""

from prophet import Prophet
from prophet.plot import plot_plotly

df = dados.rename(columns={"Data": "ds", "Preço": "y"})

df_train = df.loc[df['ds'] < '2023-01-01']
df_test = df.loc[df['ds'] >= '2023-01-01']
h_prophet = df_test['ds'].nunique()

df.shape

h_prophet = df_test['ds'].nunique()

h_prophet

m = Prophet()
m.fit(df_train)

future = m.make_future_dataframe(periods=h_prophet, freq="B")

forecast = m.predict(future)
forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()

forecast = forecast.sort_values(by='ds', ascending=False)

forecast = forecast.reset_index(drop=True)

print(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head())

fig = m.plot(forecast, figsize=(10,5))
plt.legend(['Real', 'Previsão', 'Intervalo de Confiança'])
plt.show()

plot_plotly(m, forecast, figsize=(800, 400))

fig, ax = plt.subplots(figsize = (10,3))
fig.suptitle('Previsão do Preço do Petróleo')

treino_prophet_2020m = df_train.loc[df_train['ds'] >= '2020-01-01']
pred_prophet = forecast.iloc[-h_prophet:]

dados_treino, = plt.plot(treino_prophet_2020m['ds'], treino_prophet_2020m['y'],"b", label = "Histórico")
dados_teste, = plt.plot(df_test['ds'], df_test['y'], "r", label = "Real")
dados_pred, = plt.plot(pred_prophet['ds'], pred_prophet['yhat'], "g", label = "Forecast")
plt.legend(handles=[dados_treino, dados_teste, dados_pred])
plt.xlabel('Período')
plt.show()

mae_prophet = mean_absolute_error(df_test['y'], pred_prophet['yhat'])
mse_prophet = mean_squared_error(df_test['y'], pred_prophet['yhat'])
rmse_prophet = math.sqrt(mse_prophet)
mape_prophet = mean_absolute_percentage_error(df_test['y'], pred_prophet['yhat'])
wmape_prophet = wmape(df_test['y'], pred_prophet['yhat'])
print(f"MAE: {mae_prophet:.5f}")
print(f"MSE: {mse_prophet:.5f}")
print(f"RMSE: {rmse_prophet:.5f}")
print(f"MAPE: {mape_prophet:.2%}")
print(f"WMAPE: {wmape_prophet:.2%}")

forecast = m.predict(future)
forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head()

forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()

import pandas as pd

# Supondo que 'forecast' seja seu DataFrame de previsões
forecast_df = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()

# Caminho local para salvar o arquivo CSV
file_path = 'C:/Users/phaol/OneDrive/fiap/forecast_data.csv'

# # Salvar o DataFrame como CSV
# forecast_df.to_csv(file_path, index=False)

# print(f'Arquivo salvo em: {file_path}')

"""# DEPLOY E MVP

## Planejamento do Deploy em Produção do Modelo

Primeiro, defina as ferramentas e o fluxo de trabalho para o deploy em produção, levando em conta:

*  Modelo e Frameworks: Certifique-se de que o modelo ARIMA, as bibliotecas de machine learning e os scripts estejam prontos e integrados.
*  Infraestrutura para Automação: Utilize ferramentas de automação (ex.: CRON no Linux ou serviços como AWS Lambda) para agendar a execução diária do modelo.
*  Banco de Dados ou Armazenamento em Nuvem: Configure um banco de dados (como MySQL, PostgreSQL) ou use armazenamento em nuvem (como AWS S3 ou Google Cloud Storage) para salvar os resultados diários da previsão.
*  Integração com Power BI: Utilize uma fonte de dados que o Power BI possa consultar e atualizar automaticamente, como uma URL com um arquivo JSON/CSV atualizado pelo Streamlit ou por uma API.

**Plano de Deploy em Produção**

Para colocar seu modelo em produção, o plano envolve as seguintes etapas:

Etapas do Deploy:
Preparação do Modelo:

Faça o treinamento e a validação de seu modelo utilizando dados históricos.
Salve o modelo treinado usando joblib ou pickle:
"""

import joblib

# essa célula vai ser usada pro último modelo que teve a célula executada

joblib.dump(forecast_df, 'previsao_petroleo.pkl')

from flask import Flask, request, jsonify
import joblib

app = Flask(__name__)
model = joblib.load('previsao_petroleo.pkl')

@app.route('/previsao', methods=['GET'])
def previsao():
    data = request.args.get('data')  # Recebe a data como parâmetro
    forecast = model.predict([[data]])  # Previsão
    return jsonify({'previsao': forecast[0]})

if __name__ == "__main__":
    app.run(debug=True)

"""**Hospedagem:**

Use um serviço como AWS, Google Cloud ou Heroku para hospedar a API.
Configure o servidor de forma que o modelo seja carregado e executado sem problemas.

**Monitoramento:**

Implemente logs e monitoramento do modelo para garantir que ele continue performando bem em produção.

## Criar o MVP do Modelo em Produção com Streamlit

Para desenvolver um MVP com Streamlit, você pode criar uma interface simples que exibe a previsão diária do preço do petróleo e salva os resultados em um arquivo CSV ou JSON acessível pelo Power BI.
"""

pip install streamlit

import streamlit as st
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import datetime

# Função para carregar os dados e ajustar o modelo
def forecast_model(data):
    # Aqui você deve inserir seu pré-processamento e o ajuste do modelo
    modelo = ARIMA(data['preco'], order=(2, 1, 2))  # Ajuste com os parâmetros adequados
    modelo_fit = modelo.fit()
    forecast = modelo_fit.forecast(steps=1)
    return forecast[0]

# Baixar o arquivo Excel usando wget (isso pode ser feito no Colab antes de executar o Streamlit)
# No Streamlit, você não precisa fazer isso, mas, em um ambiente local, o download pode ser feito manualmente
import os
if not os.path.exists('ipeadata.xlsx'):
    !wget 'https://raw.githubusercontent.com/marialuisamartins/tech_fase4/6ad3e07bc901fd984eedb3030510b2816aaf7383/ipeadata%5B03-11-2024-01-09%5D.xlsx' -O ipeadata.xlsx

# Ler o arquivo Excel
ipeadata = pd.read_excel('ipeadata.xlsx', engine='openpyxl')

# Definir a coluna 'data' como índice e filtrar para a partir de 2021
ipeadata['data'] = pd.to_datetime(ipeadata['data'])
ipeadata.set_index('data', inplace=True)
ipeadata_filtered = ipeadata[ipeadata.index >= '2021-01-01']

# Gera a previsão
previsao_hoje = forecast_model(ipeadata_filtered)

# Mostra a previsão na interface Streamlit
st.title("Previsão Diária do Preço do Petróleo")
st.write(f"Previsão para o próximo dia: {previsao_hoje:.2f}")

# Salvar a previsão com a data de hoje
hoje = datetime.date.today()
forecast_df = pd.DataFrame({'Data': [hoje], 'Previsao_Prec': [previsao_hoje]})
# forecast_df.to_csv('/mnt/data/previsao_petroleo.csv', index=False)

# st.write("A previsão foi salva com sucesso!")

import streamlit as st
import pandas as pd
import pickle
from prophet import Prophet
import matplotlib.pyplot as plt

# Configuração inicial do Streamlit
st.set_page_config(page_title='Dashboard de Previsão do Petróleo', layout='wide')

# Funções auxiliares
@st.cache_resource
def carregar_dados():
    """Carregar os dados de petróleo do arquivo ipeadata.xlsx."""
    try:
        arquivo = "ipeadata.xlsx"  # Ajuste o caminho se necessário
        dados = pd.read_excel(arquivo, engine="openpyxl")
        dados['data'] = pd.to_datetime(dados['data'])
        dados = dados.rename(columns={"data": "ds", "preco": "y"})  # Adequação para Prophet
        return dados
    except FileNotFoundError:
        st.error("Arquivo `ipeadata.xlsx` não encontrado. Certifique-se de que o arquivo está no diretório correto.")
        return None

@st.cache_resource
def carregar_modelo():
    """Carregar o modelo Prophet treinado."""
    try:
        arquivo_modelo = "modelo_prophet.pkl"
        with open(arquivo_modelo, "rb") as f:
            modelo = pickle.load(f)
        return modelo
    except FileNotFoundError:
        st.error("Arquivo `modelo_prophet.pkl` não encontrado. Certifique-se de que o modelo está no diretório correto.")
        return None

# Carregando dados e modelo
dados = carregar_dados()
modelo = carregar_modelo()

if dados is not None and modelo is not None:
    # Visualização dos dados
    st.title("Dashboard de Previsão do Preço do Petróleo")
    st.write("### Dados históricos do preço do petróleo")
    st.dataframe(dados.tail(30))  # Mostrar os últimos 30 dias

    # Gráfico dos dados históricos
    st.write("### Gráfico de Preços Históricos")
    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(dados['ds'], dados['y'], label="Preço Histórico", color='blue')
    ax.set_title("Histórico de Preços do Petróleo")
    ax.set_xlabel("Data")
    ax.set_ylabel("Preço (USD)")
    ax.legend()
    st.pyplot(fig)

    # Previsão com Prophet
    st.write("### Previsão com Modelo Prophet")
    periodos = st.slider("Escolha o número de dias para previsão:", min_value=1, max_value=60, value=30)
    if st.button("Gerar Previsão"):
        futuro = modelo.make_future_dataframe(periods=periodos)
        previsao = modelo.predict(futuro)

        # Exibir a previsão
        st.write("#### Resultados da Previsão")
        st.dataframe(previsao[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(periodos))

        # Gráfico da previsão
        st.write("### Gráfico da Previsão")
        fig2, ax2 = plt.subplots(figsize=(10, 5))
        ax2.plot(previsao['ds'], previsao['yhat'], label="Previsão", color='green')
        ax2.fill_between(previsao['ds'], previsao['yhat_lower'], previsao['yhat_upper'], color='gray', alpha=0.3, label="Intervalo de Confiança")
        ax2.set_title("Previsão do Preço do Petróleo")
        ax2.set_xlabel("Data")
        ax2.set_ylabel("Preço (USD)")
        ax2.legend()
        st.pyplot(fig2)

    # Orientações para Deploy
    st.write("### Orientações para Deploy")
    st.markdown("""
    - Utilize plataformas como Streamlit Cloud, AWS ou Google Cloud para hospedar o aplicativo.
    - Certifique-se de carregar os arquivos necessários (dados e modelo) no ambiente de produção.
    """)
else:
    st.error("Não foi possível carregar os dados ou o modelo. Verifique os arquivos e tente novamente.")